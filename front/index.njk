<!DOCTYPE html>
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<script src="//unpkg.com/alpinejs" defer></script>
	<script src="https://cdn.tailwindcss.com"></script>
	<script src="/app/assets/deps/markdown-it.min.js"></script>
	<script src="/app/assets/deps/markdown-it-math.min.js"></script>
	<title>Front</title>
	<script>
		document.addEventListener("alpine:init", () => {
			Alpine.store("dir", {
				init() {
					this.value = localStorage.getItem("dir") || null
				},
				value: null,
				async askForDir() {
					let dir = await selectDir()
					if (dir != null) {
						localStorage.setItem("dir", dir)
						this.value = dir
					}
				}
			})
			Alpine.store("filecontent", "")
		})
	</script>
	<script>
		const md = markdownit().use(markdownitMath)
	</script>
	<script>
		async function setUpReload() {
			let versionNumber = await (await fetch("/app/version")).text()
			setInterval(async () => {
				let newVersion = await (await fetch("/app/version")).text()
				if (newVersion !== versionNumber) {
					location.reload()
				}
			}, 200)
		}
		setUpReload()

		// -> Promise<string|null>
		async function selectDir() {
			try {
				let dir = await (await fetch("/selectdir")).text()
				return dir
			} catch {
				return null
			}
		}

		// File = {type: "File"}
		// Dir = {type: "Dir": children: [string, File|Dir][]}
		// string -> Promise<Dir|null>
		async function readDir(path) {
			try {
				let value = await (await fetch("/readdir" + path)).json()
				return value
			} catch(e) {
				console.warn(e)
				return null
			}
		}

		// string, string -> Promise<boolean>
		async function writeFile(path, content) {
			try {
				let value = await fetch("/writefile" + path, {
					method: "POST",
					body: content,
				})
				if (!value.ok) {
					return false
				}
				return true
			} catch(e) {
				console.warn(e)
				return false
			}
		}

		// string -> Promise<boolean>
		async function deleteFile(path) {
			try {
				let value = await fetch("/deletefile" + path, {
					method: "DELETE",
				})
				if (!value.ok) {
					return false
				}
				return true
			} catch(e) {
				console.warn(e)
				return false
			}
		}

		// string, string -> Promise<boolean>
		async function renameFile(path, newPath) {
			try {
				let file = await readFile(path)
				if (file == null) {
					return false
				}
				if (writeFile(newPath, file) == false) {
					return false
				}
				if (deleteFile(path) == false) {
					return false
				}
				return true
			}
			catch {
				return false
			}
		}

		// Dir -> string[]
		function flatDir(dir) {
			let items = dir.value.map(([path, value]) => {
				if (value.type == "File") {
					return path
				} else {
					return flatDir(value)
				}
			})
			return items.flat(Infinity)
		}

		// string -> string[]
		async function getMdFiles(path) {
			let files = flatDir(await readDir(path))
			return files.filter(file => file.endsWith(".md"))
		}

		// string -> Promise<String|null>
		// TODO: Fail on null
		async function readFile(path) {
			try {
				let res = await fetch("/readfile" + path)
				if (!res.ok) {
					return null
				}
				return await res.text()
			} catch(e) {
				console.warn(e)
				return null
			}
		}

		// string -> string
		function simplify(str) {
			return str.toLowerCase().normalize("NFD").replace(/[^a-z]/g, "")
		}
	</script>
	<style type="text/css">
		.noscrollbar {
			scrollbar-width: none;
			-ms-overflow-style: none;
		}
		.noscrollbar::-webkit-scrollbar {
			display: none;
		}
	</style>
</head>
<body class="overflow-hidden h-screen">
	{%- from "_includes/searcher.njk" import searcher -%}
	{%- from "_includes/overlay.njk" import overlay -%}
	<div 
	    x-data="{selectedFile: null, content: '', changed: false}"
		x-effect="content = ((await readFile(selectedFile || '')) || '').slice(0, -1)" 
	>
		<div 
			x-data="{width: 50, grabbing: false}"
			class="flex items-stretch content-stretch w-screen h-screen"
		>
			<textarea 
				x-model="content"
				class="p-4 resize-none noscrollbar"
				:style="`width: ${width}vw`"
				@input="changed = true"
				placeholder="Press Ctrl+M"
				@keydown.window.prevent.ctrl.s="changed = false; writeFile(selectedFile, content + '\n')"
				:disabled="selectedFile == null"
				id="textarea"
			></textarea>
			<div 
				class="w-1 bg-slate-200 hover:cursor-move"
				@mousemove.window="if (grabbing) width = $event.clientX * 100 / window.innerWidth"
				@mousedown="grabbing=true"
				@mouseup.window="grabbing=false"
			></div>
			<div class="bg-red-100 overflow-x-hidden overflow-y-auto noscrollbar" :style="`width: ${100 - width}vw`" class="min-w-0">
				<style type="text/css" scoped>
					#rendered * {
						all: revert;
					}
				</style>
				<div class="px-6" x-html="md.render(content)" id="rendered"></div>
			</div>
		</div>
		{{ searcher(
			"(file) => {selectedFile = file; changed = false; document.getElementById('textarea').focus()}",
			"(file) => {let newFile = prompt('Rename ' + file.slice($store.dir.value.length + 1) + ' (Or leave empty to cancel)'); if(newFile != '') {renameFile(file, $store.dir.value + '/' + newFile)} }",
			"(file) => {if(confirm('Delete ' + file.slice($store.dir.value.length + 1) + '?')) deleteFile(file)}"
		) }}
		{{ overlay("changed", "selectedFile != null ? selectedFile.slice($store.dir.value.length + 1) : ''") }}
	</div>
</body>
